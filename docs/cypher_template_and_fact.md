# CypherTemplate, Fact и версионирование

## CypherTemplate: описание и структура

`CypherTemplate` — это описание способа преобразования нарративного текста в Cypher-код, который создаёт узлы и связи в графовой модели, и, при необходимости, создаёт `Fact` — универсальное утверждение, подлежащее версионированию.

Каждый шаблон:
- описывает **слоты** — переменные, которые нужно извлечь;
- содержит **Cypher-код**, использующий эти слоты;
- опционально определяет **факт**, который должен быть зафиксирован в истории.

### Структура

| Поле            | Назначение |
|-----------------|------------|
| `id`            | Уникальный идентификатор шаблона |
| `version`       | Версия шаблона, формат SemVer |
| `title`         | Короткое название |
| `description`   | Описание |
| `details`       | Подробное описание |
| `category`      | Классификация шаблона (напр. EventInsert) |
| `slots`         | Список переменных, которые нужны шаблону |
| `cypher`        | Шаблон Cypher-кода, использующий переменные |
| `fact_descriptor` | Если задан, указывает, что шаблон создаёт `Fact` |
| `vector`        | Эмбеддинг шаблона (используется для поиска по смыслу) |

### Пример CypherTemplate

```json
{
  "id": "membership_change",
  "version": "1.0.0",
  "title": "Membership change",
  "description": "Character joins or leaves a faction",
  "details": "...",
  "slots": [
    {"name": "character", "type": "STRING", "description": "Имя героя"},
    {"name": "faction", "type": "STRING", "description": "Название фракции"},
    {"name": "chapter", "type": "INT", "description": "Глава"},
    {"name": "summary", "type": "STRING", "required": false}
  ],
  "cypher": "...",
  "fact_descriptor": {
    "predicate": "MEMBER_OF",
    "subject": "$character",
    "value": "$faction",
    "object": "$faction"
  }
}
```

---

## Fact: зачем он нужен

`Fact` — это универсальный, версионируемый узел, отражающий утверждённое знание на определённый момент истории.

### Назначения:
1. **Хронология** — каждый факт фиксирует диапазон глав, когда он был актуален (`from_chapter`, `to_chapter`).
2. **Версионирование** — при появлении нового значения старый факт закрывается, новый создаётся, между ними создаётся связь `PRECEDED_BY`.
3. **Аудит** — можно отследить, какое событие или шаблон породил факт.
4. **Обнаружение конфликтов** — сравнение эмбеддингов позволяет найти противоречия автоматически.

### Структура Fact

| Поле | Назначение |
|------|------------|
| `id` | Уникальный идентификатор |
| `subject_id` | Кому принадлежит факт (id узла) |
| `predicate` | Что утверждается: MEMBER_OF, HAS_TRAIT и т.п. |
| `value` | Значение: может быть имя фракции, черта, статус и т.п. |
| `object_id` | Необязательный id объекта, на который направлен факт |
| `from_chapter` | Глава, с которой утверждение действительно |
| `to_chapter` | Глава, до которой утверждение действительно (или `null`) |
| `summary` | Текстовое пояснение |
| `vector` | Эмбеддинг утверждения, для поиска конфликтов и дубликатов |

### Пример Fact

```json
{
  "id": "fact-123",
  "subject_id": "Aren",
  "predicate": "MEMBER_OF",
  "value": "Night Front",
  "object_id": "faction-77",
  "from_chapter": 5,
  "to_chapter": null,
  "summary": "Арен вступил в Северный фронт",
  "vector": [0.032, 0.741, ...]
}
```

---

## Версионирование

Когда шаблон создаёт факт, пайплайн должен:
1. Найти все активные факты с тем же `subject_id` и `predicate`.
2. Вычислить эмбеддинг нового утверждения.
3. Если найденный факт семантически близок (distance < 0.15), но `value` отличается:
   - Закрыть старый (`to_chapter = current - 1`)
   - Создать новый, связав `PRECEDED_BY`.

---

## Что такое Fact и зачем он вообще нужен

| Роль | Зачем это нужно движку | Как это реализовано |
|------|-----------------------|---------------------|
| **Исторический “слепок”** | фиксирует *когда-то* утверждённую истину, чтобы в будущем можно было спросить «а как было на 3-й главе?» | свойства `from_chapter`, `to_chapter` (​`null` → всё ещё актуально) |
| **Версионирование** | при появлении нового (противоречащего или уточняющего) значения старый `Fact` закрывается, новый открывается, а между ними ставится `(:Fact)-[:PRECEDED_BY]->(:Fact)` | единый алгоритм, одинаковый для всех типов фактов |
| **Отладка / аудит** | ясно видно, *какое событие* породило факт и *кто* это сделал | связь `(:Event)-[:ASSERTED]->(:Fact)` |
| **Дедупликатор и детектор конфликтов** | быстрый векторный поиск похожих фактов → можно решить, дубликат ли это, изменение или ошибка | поле `vector` + HNSW-индекс |
| **Точка агрегации для аналитики** | удобно строить отчёты / explain-графы не трогая доменную модель | все `Fact` имеют одинаковую схему ⇒ одна выборка обслуживает все типы |

### Ключевая идея:
`Fact` — *вспомогательный* универсальный узел, делающий граф “трёхмерным” (ось времени + ось версий) и не вмешивающийся в «чистые» доменные рёбра, которые создаёт Cypher-шаблон.


# Приложение

## 1. Что такое Fact и зачем он вообще нужен

| Роль | Зачем это нужно движку | Как это реализовано |
|------|-----------------------|---------------------|
| **Исторический “слепок”** | фиксирует *когда-то* утверждённую истину, чтобы в будущем можно было спросить «а как было на 3-й главе?» | свойства `from_chapter`, `to_chapter` (`null` → всё ещё актуально) |
| **Версионирование** | при появлении нового (противоречащего или уточняющего) значения старый `Fact` закрывается, новый открывается, а между ними ставится `(:Fact)-[:PRECEDED_BY]->(:Fact)` | единый алгоритм, одинаковый для всех типов фактов |
| **Отладка / аудит** | ясно видно, *какое событие* породило факт и *кто* это сделал | связь `(:Event)-[:ASSERTED]->(:Fact)` |
| **Дедупликатор и детектор конфликтов** | быстрый векторный поиск похожих фактов → можно решить, дубликат ли это, изменение или ошибка | поле `vector` + HNSW-индекс |
| **Точка агрегации для аналитики** | удобно строить отчёты / explain-графы не трогая доменную модель | все `Fact` имеют одинаковую схему ⇒ одна выборка обслуживает все типы |

### Ключевая идея

`Fact` — *вспомогательный* универсальный узел, делающий граф “трёхмерным” (ось времени + ось версий) и не вмешивающийся в «чистые» доменные рёбра, которые создаёт Cypher-шаблон.

---

## 2. Минимальная и универсальная схема Fact

```cypher
// ➊ Узел
(:Fact {
  id:             string ,  // uuid
  subject_id:     string ,  // node-id или натуральный ключ субъекта
  predicate:      string ,  // MEMBER_OF, HAS_TRAIT, OWNS_ITEM …
  value:          string ,  // Night Front, "бесстрашная", "true"
  object_id:      string?,  // если есть объект (Faction, Item …)
  from_chapter:   int   ,   // версия начала действия
  to_chapter:     int?  ,   // null = актуально
  summary:        string?,  // произвольное пояснение
  vector:         number[]  // 1536-d embedding — канонизированная строка
})
// ➋ Связи
(:Event)-[:ASSERTED]->(:Fact)
(:Fact)-[:REFERS_TO]->(obj?)           // если object_id задан
(:Fact)-[:PRECEDED_BY]->(:Fact)        // цепочка версий
```

> Никаких дополнительных полей (status, strength, hp…) — всё хранится либо как строка в `value`, либо как “нормальные” доменные рёбра/проперти, которые создаёт сам Cypher-шаблон.

---

## 3. Что тогда хранить в CypherTemplate?

Шаблону достаточно знать **три вещи** о факте, чтобы заполнить универсальные поля:

| Поле         | Что кладём                                | Откуда берём             |
|--------------|--------------------------------------------|---------------------------|
| `predicate`  | строка-константа (`MEMBER_OF`, ...)        | зашита в шаблоне          |
| `subject_id` | id узла, который шаблон уже `MERGE`-ит     | выражение `$character.id` |
| `value`      | одна из переменных слотов                  | например `$faction`       |
| `object_id` *(опц.)* | если факт направлен на другой узел | `$faction.id`             |

### Новый минимальный блок-метаданные в `CypherTemplate`

```jsonc
"fact_descriptor": {
  "predicate": "MEMBER_OF",
  "subject":  "$character",
  "value":    "$faction",          // или "$status", или константа
  "object":   "$faction"           // опционально
}
```

> Больше ничего не нужно – ни `fact_policy`, ни `fact_value_slot`, ни отдельного `fact_type`.

---

## 4. Как шаблон создаёт Fact

```jinja
// Шаг 1. Доменные узлы и рёбра (как обычно)
MERGE (c:Character {name:'{{ character }}'})
MERGE (f:Faction   {name:'{{ faction }}'})
MERGE (c)-[:MEMBER_OF]->(f)

// Шаг 2. Универсальный блок Fact
{% include 'universal_fact.j2' with context({
    "subject_id": "c",          // alias ноды в текущем MATCH-контексте
    "object_id":  "f",
    "predicate":  "MEMBER_OF",
    "value":      "{{ faction }}",
    "chapter":    chapter,
    "summary":    summary
}) %}
```

> Файл-инклюд `universal_fact.j2` закрывает старую версию (если надо), генерирует embedding канонической строки  
> `"MEMBER_OF‖{{ character }}‖{{ faction }}"`, кладёт его в поле `vector` и создаёт новую запись.

---

## 5. Проверка на противоречие (универсальна для любого факта)

```cypher
// 1. Канонизируем новое утверждение и считаем embedding $vec
WITH "MEMBER_OF‖Aren‖Night Front" AS canon, chapter, summary
CALL embedding.encode(canon) YIELD vector AS $vec

// 2. Ищем актуальные факты того же predicate + subject
MATCH (old:Fact)
WHERE old.subject_id = $aren_id
  AND old.predicate  = "MEMBER_OF"
  AND old.to_chapter IS NULL
WITH old, gds.similarity.cosine(old.vector, $vec) AS sim

// 3. Семантически близкие, но value отличается → версия
WHERE sim >= 0.85 AND old.value <> "Night Front"
SET old.to_chapter = chapter - 1
CREATE (new:Fact {id: randomUUID(), predicate:"MEMBER_OF",
                  subject_id:$aren_id, value:"Night Front",
                  from_chapter:chapter, vector:$vec})
CREATE (old)-[:PRECEDED_BY]->(new)
```

> Алгоритм идентичен для `HAS_TRAIT`, `OWNS_ITEM` и любых будущих типов — благодаря универсальному формату.

---

## 6. Почему это соответствует вашей задумке

- **Универсальность** — все факты одного формата; шаблон лишь подставляет строки.
- **Версионирование** — реализовано единственным `PRECEDED_BY`-паттерном.
- **“Классические” графовые связи** — живут рядом и строятся чистым Cypher’ом, не зависят от `Fact`.
- **Расширяемость** — новый шаблон → просто другая константа `predicate`.
- **Поисковая/конфликтная логика** — одинакова для всех, опирается на эмбеддинг.

> Таким образом `Fact` остаётся компактным «слоем истории», а доменная модель в графе — чистой и подробной.